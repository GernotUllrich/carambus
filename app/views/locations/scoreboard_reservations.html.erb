<!--suppress RubyScope, RubyScope, RubyScope -->
<!--suppress RubyScope, RubyScope, RubyScope -->
<!--<script src="https://unpkg.com/hotkeys-js/dist/hotkeys.js"></script>-->
<style>
    .responsive-svg {
        width: 100%;
        height: auto;
    }
    
    /* Kiosk Keyboard Styles */
    .kiosk-keyboard {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: #2d3748;
        padding: 20px;
        z-index: 1000;
        display: none;
    }
    
    .kiosk-keyboard.show {
        display: block;
    }
    
    .kiosk-keyboard .keyboard__keys {
        display: flex;
        justify-content: center;
        gap: 10px;
        flex-wrap: wrap;
    }
    
    .kiosk-keyboard .keyboard__key {
        padding: 15px 20px;
        border: none;
        border-radius: 8px;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        min-width: 80px;
        text-align: center;
    }
    
    .kiosk-keyboard .keyboard__key--wide {
        min-width: 120px;
    }
    
    .kiosk-keyboard .keyboard__key--extra-wide {
        min-width: 200px;
    }
    
    .kiosk-keyboard .keyboard__key--dark {
        background: #e53e3e;
        color: white;
    }
    
    .kiosk-keyboard .keyboard__key--activatable {
        background: #4a5568;
        color: white;
    }
    
    .kiosk-keyboard .keyboard__key--active {
        background: #2d3748;
    }
</style>
<!--<script src="/hotkeys.js"></script>-->
<script src="/onscreen-keyboard.js?v=<%= Time.current.to_i %>"></script>
<script type="text/javascript">

  function new_reservation_mode() {
    set_new_reservation_modal();
  }

  function set_new_reservation_modal() {
    document.getElementById("modal-new-reservation").classList.toggle("hidden");
    document.getElementById("modal-new-reservation" + "-bg").classList.toggle("hidden");
    document.getElementById("modal-new-reservation").classList.toggle("flex");
    document.getElementById("modal-new-reservation" + "-bg").classList.toggle("flex");
  }

  function open_kiosk_keyboard() {
    logMessage("Opening kiosk keyboard...");
    logMessage("Keyboard object available: " + (typeof Keyboard !== 'undefined'));
    
    // Force fallback keyboard for testing
    logMessage("Forcing fallback keyboard for testing");
    showFallbackKioskKeyboard();
    
    // Original logic (commented out for now)
    /*
    if (typeof Keyboard !== 'undefined' && Keyboard._setupKeyboard) {
      logMessage("Using main keyboard with kiosk layout");
      Keyboard._setupKeyboard("kiosk");
      Keyboard.open("", null, null);
    } else {
      logMessage("Using fallback kiosk keyboard");
      showFallbackKioskKeyboard();
    }
    */
  }

  function showFallbackKioskKeyboard() {
    logMessage("Creating fallback kiosk keyboard...");
    
    // Create fallback kiosk keyboard if it doesn't exist
    let kioskKeyboard = document.getElementById('fallback-kiosk-keyboard');
    if (!kioskKeyboard) {
      logMessage("Building new fallback keyboard...");
      kioskKeyboard = document.createElement('div');
      kioskKeyboard.id = 'fallback-kiosk-keyboard';
      kioskKeyboard.className = 'kiosk-keyboard';
      kioskKeyboard.style.cssText = `
        position: fixed !important;
        bottom: 0 !important;
        left: 0 !important;
        right: 0 !important;
        background: #2d3748 !important;
        padding: 20px !important;
        z-index: 9999 !important;
        display: block !important;
        border-top: 3px solid #e53e3e !important;
      `;
      kioskKeyboard.innerHTML = `
        <div class="keyboard__keys" style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;">
          <button type="button" class="keyboard__key keyboard__key--wide keyboard__key--activatable" id="alt-key" style="padding: 15px 20px; border: none; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; min-width: 120px; text-align: center; background: #4a5568; color: white;">ALT</button>
          <button type="button" class="keyboard__key keyboard__key--extra-wide" id="space-key" style="padding: 15px 20px; border: none; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; min-width: 200px; text-align: center; background: #718096; color: white;">
            <i class="material-icons">space_bar</i>
          </button>
          <button type="button" class="keyboard__key keyboard__key--wide keyboard__key--dark" id="exit-kiosk-key" style="padding: 15px 20px; border: none; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; min-width: 120px; text-align: center; background: #e53e3e; color: white;">EXIT KIOSK</button>
          <button type="button" class="keyboard__key keyboard__key--wide keyboard__key--dark" id="close-kiosk-key" style="padding: 15px 20px; border: none; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; min-width: 120px; text-align: center; background: #e53e3e; color: white;">CLOSE</button>
          <button type="button" class="keyboard__key keyboard__key--wide" id="debug-key" style="padding: 15px 20px; border: none; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; min-width: 120px; text-align: center; background: #805ad5; color: white;">DEBUG</button>
          <button type="button" class="keyboard__key keyboard__key--wide" id="logs-key" style="padding: 15px 20px; border: none; border-radius: 8px; font-size: 18px; font-weight: bold; cursor: pointer; min-width: 120px; text-align: center; background: #38a169; color: white;">LOGS</button>
        </div>
      `;
      document.body.appendChild(kioskKeyboard);
      logMessage("Keyboard element added to DOM");
      
      // Add event listeners
      let altPressed = false;
      
      document.getElementById('alt-key').addEventListener('click', function() {
        logMessage("ALT key clicked, current state: " + altPressed);
        altPressed = !altPressed;
        this.classList.toggle('keyboard__key--active', altPressed);
        this.style.backgroundColor = altPressed ? '#2d3748' : '#4a5568';
        logMessage("ALT key state changed to: " + altPressed);
      });
      
      document.getElementById('space-key').addEventListener('click', function() {
        logMessage("SPACE key clicked, ALT pressed: " + altPressed);
        if (altPressed) {
          logMessage("ALT+SPACE combination triggered");
          fireAltSpaceEvent();
          altPressed = false;
          document.getElementById('alt-key').classList.remove('keyboard__key--active');
          document.getElementById('alt-key').style.backgroundColor = '#4a5568';
        } else {
          logMessage("SPACE clicked without ALT");
        }
      });
      
      document.getElementById('exit-kiosk-key').addEventListener('click', function() {
        logMessage("EXIT KIOSK button clicked");
        fireAltSpaceEvent();
      });
      
      document.getElementById('close-kiosk-key').addEventListener('click', function() {
        logMessage("CLOSE button clicked");
        kioskKeyboard.style.display = 'none';
      });
      
      document.getElementById('debug-key').addEventListener('click', function() {
        logMessage("DEBUG button clicked");
        logMessage("Current window properties:");
        logMessage("- document.fullscreenElement: " + document.fullscreenElement);
        logMessage("- window.innerHeight: " + window.innerHeight);
        logMessage("- window.innerWidth: " + window.innerWidth);
        logMessage("- window.screen.height: " + window.screen.height);
        logMessage("- window.screen.width: " + window.screen.width);
        logMessage("- navigator.userAgent: " + navigator.userAgent.substring(0, 50) + "...");
        
        // Try to detect if we're in kiosk mode
        const isKiosk = window.innerHeight === window.screen.height && window.innerWidth === window.screen.width;
        logMessage("Detected kiosk mode: " + isKiosk);
        
        // Show alert with debug info
        alert(`Debug Info:
- Fullscreen: ${document.fullscreenElement ? 'Yes' : 'No'}
- Window size: ${window.innerWidth}x${window.innerHeight}
- Screen size: ${window.screen.width}x${window.screen.height}
- Kiosk detected: ${isKiosk}
- User Agent: ${navigator.userAgent.substring(0, 50)}...`);
      });
      
      document.getElementById('logs-key').addEventListener('click', function() {
        showDebugLogs();
      });
      
      logMessage("Fallback keyboard event listeners added");
    }
    
    kioskKeyboard.style.display = 'block';
    logMessage("Fallback keyboard shown");
  }

  function fireAltSpaceEvent() {
    logMessage("Firing ALT+SPACE event...");
    
    // Method 1: Try ESC key FIRST (since physical ESC works)
    try {
      logMessage("Trying ESC key (primary method)...");
      const escEvent = new KeyboardEvent("keydown", {
        key: "Escape",
        code: "Escape",
        keyCode: 27,
        which: 27,
        bubbles: true,
        cancelable: true,
        view: window
      });
      document.dispatchEvent(escEvent);
      
      // Also try keyup event
      setTimeout(() => {
        const escUpEvent = new KeyboardEvent("keyup", {
          key: "Escape",
          code: "Escape",
          keyCode: 27,
          which: 27,
          bubbles: true,
          cancelable: true,
          view: window
        });
        document.dispatchEvent(escUpEvent);
        logMessage("ESC keyup event sent");
      }, 50);
      
    } catch (e) {
      logMessage("ESC method failed: " + e.message);
    }
    
    // Method 2: Try direct window.focus() 
    setTimeout(() => {
      try {
        window.focus();
        logMessage("Window focus attempted");
      } catch (e) {
        logMessage("Window focus failed: " + e.message);
      }
    }, 100);
    
    // Method 3: Try to trigger window menu (Linux desktop environment)
    setTimeout(() => {
      try {
        // Create a more aggressive ALT+SPACE event
        const altDownEvent = new KeyboardEvent("keydown", {
          key: "Alt",
          code: "AltLeft",
          keyCode: 18,
          which: 18,
          altKey: true,
          bubbles: true,
          cancelable: true,
          view: window,
          composed: true
        });

        const spaceDownEvent = new KeyboardEvent("keydown", {
          key: " ",
          code: "Space",
          keyCode: 32,
          which: 32,
          altKey: true,
          bubbles: true,
          cancelable: true,
          view: window,
          composed: true
        });

        const spaceUpEvent = new KeyboardEvent("keyup", {
          key: " ",
          code: "Space",
          keyCode: 32,
          which: 32,
          altKey: true,
          bubbles: true,
          cancelable: true,
          view: window,
          composed: true
        });

        const altUpEvent = new KeyboardEvent("keyup", {
          key: "Alt",
          code: "AltLeft",
          keyCode: 18,
          which: 18,
          altKey: false,
          bubbles: true,
          cancelable: true,
          view: window,
          composed: true
        });

        // Dispatch events in sequence with longer delays
        logMessage("Dispatching ALT+SPACE events...");
        document.dispatchEvent(altDownEvent);
        setTimeout(() => {
          document.dispatchEvent(spaceDownEvent);
          setTimeout(() => {
            document.dispatchEvent(spaceUpEvent);
            setTimeout(() => {
              document.dispatchEvent(altUpEvent);
              logMessage("ALT+SPACE events completed");
              
              // Method 2.1: Try to click on "Fullscreen" menu item after ALT+SPACE
              setTimeout(() => {
                try {
                  logMessage("Trying to click on Fullscreen menu item...");
                  // Look for menu items that might contain "Fullscreen" text
                  const menuItems = document.querySelectorAll('*');
                  for (let item of menuItems) {
                    if (item.textContent && item.textContent.toLowerCase().includes('fullscreen')) {
                      logMessage("Found Fullscreen menu item, clicking...");
                      item.click();
                      break;
                    }
                  }
                } catch (e) {
                  logMessage("Menu item click failed: " + e.message);
                }
              }, 200);
              
            }, 100);
          }, 100);
        }, 100);
      } catch (e) {
        logMessage("Method 2 failed: " + e.message);
      }
    }, 200);
    
    // Method 4: Try F11 to toggle fullscreen
    setTimeout(() => {
      try {
        logMessage("Trying F11 to exit fullscreen...");
        const f11Event = new KeyboardEvent("keydown", {
          key: "F11",
          code: "F11",
          keyCode: 122,
          which: 122,
          bubbles: true,
          cancelable: true,
          view: window
        });
        document.dispatchEvent(f11Event);
      } catch (e) {
        logMessage("F11 method failed: " + e.message);
      }
    }, 500);
    
    // Method 5: Try Super+Down (Linux window management)
    setTimeout(() => {
      try {
        logMessage("Trying Super+Down (Linux window management)...");
        const superDownEvent = new KeyboardEvent("keydown", {
          key: "ArrowDown",
          code: "ArrowDown",
          keyCode: 40,
          which: 40,
          metaKey: true, // Super key
          bubbles: true,
          cancelable: true,
          view: window
        });
        document.dispatchEvent(superDownEvent);
      } catch (e) {
        logMessage("Super+Down method failed: " + e.message);
      }
    }, 1000);
    
    // Method 6: Try to exit fullscreen via browser API
    setTimeout(() => {
      try {
        logMessage("Trying to exit fullscreen via browser API...");
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (document.webkitExitFullscreen) {
          document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
          document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
          document.msExitFullscreen();
        }
        logMessage("Fullscreen exit API called");
      } catch (e) {
        logMessage("Fullscreen exit API failed: " + e.message);
      }
    }, 1500);
    
    // Method 7: Try to open browser menu programmatically
    setTimeout(() => {
      try {
        logMessage("Trying to open browser menu...");
        // Try to trigger right-click context menu
        const contextMenuEvent = new MouseEvent("contextmenu", {
          bubbles: true,
          cancelable: true,
          view: window,
          clientX: 10,
          clientY: 10
        });
        document.dispatchEvent(contextMenuEvent);
      } catch (e) {
        logMessage("Context menu method failed: " + e.message);
      }
    }, 2000);
    
    logMessage("All exit methods attempted");
  }

  // Simple logging function that saves to localStorage and shows in alert
  function logMessage(message) {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ${message}`;
    
    // Save to localStorage
    let logs = JSON.parse(localStorage.getItem('kioskDebugLogs') || '[]');
    logs.push(logEntry);
    if (logs.length > 50) logs = logs.slice(-50); // Keep only last 50 entries
    localStorage.setItem('kioskDebugLogs', JSON.stringify(logs));
    
    // Also log to console if available
    console.log(logEntry);
  }

  function showDebugLogs() {
    const logs = JSON.parse(localStorage.getItem('kioskDebugLogs') || '[]');
    if (logs.length === 0) {
      alert("No debug logs found. Try clicking 'Exit Kiosk Mode' first.");
      return;
    }
    
    const logText = logs.slice(-10).join('\n'); // Show last 10 entries
    alert("Last 10 Debug Logs:\n\n" + logText);
  }

  function clearDebugLogs() {
    localStorage.removeItem('kioskDebugLogs');
    alert("Debug logs cleared!");
  }

  function downloadDebugLogs() {
    const logs = JSON.parse(localStorage.getItem('kioskDebugLogs') || '[]');
    if (logs.length === 0) {
      alert("No debug logs found. Try clicking 'Exit Kiosk Mode' first.");
      return;
    }
    
    const logText = logs.join('\n');
    const blob = new Blob([logText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'kiosk-debug-logs.txt';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    logMessage("Debug logs downloaded as kiosk-debug-logs.txt");
  }

  function tryLinuxWindowManagement() {
    logMessage("Trying Linux-specific window management...");
    logMessage("Session type: LXDE-pi-labwc");
    logMessage("Browser started with --kiosk flag");
    
    // Method 1: Try ALT+F4 (close window)
    setTimeout(() => {
      try {
        logMessage("Trying ALT+F4...");
        const altF4Event = new KeyboardEvent("keydown", {
          key: "F4",
          code: "F4",
          keyCode: 115,
          which: 115,
          altKey: true,
          bubbles: true,
          cancelable: true,
          view: window
        });
        document.dispatchEvent(altF4Event);
      } catch (e) {
        logMessage("ALT+F4 failed: " + e.message);
      }
    }, 100);
    
    // Method 2: Try Super+Space (KDE window menu)
    setTimeout(() => {
      try {
        logMessage("Trying Super+Space...");
        const superSpaceEvent = new KeyboardEvent("keydown", {
          key: " ",
          code: "Space",
          keyCode: 32,
          which: 32,
          metaKey: true,
          bubbles: true,
          cancelable: true,
          view: window
        });
        document.dispatchEvent(superSpaceEvent);
      } catch (e) {
        logMessage("Super+Space failed: " + e.message);
      }
    }, 500);
    
    // Method 3: Try to simulate mouse click on window title bar
    setTimeout(() => {
      try {
        logMessage("Trying to click on window title bar...");
        const titleBarClick = new MouseEvent("click", {
          bubbles: true,
          cancelable: true,
          view: window,
          clientX: window.innerWidth / 2,
          clientY: 5
        });
        document.dispatchEvent(titleBarClick);
      } catch (e) {
        logMessage("Title bar click failed: " + e.message);
      }
    }, 1000);
    
    // Method 4: Try to send message to parent window
    setTimeout(() => {
      try {
        logMessage("Trying to send message to parent window...");
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({type: 'exitFullscreen'}, '*');
          logMessage("Message sent to parent window");
        }
      } catch (e) {
        logMessage("Parent window message failed: " + e.message);
      }
    }, 1500);
    
    // Method 5: Try to restart browser in non-kiosk mode
    setTimeout(() => {
      try {
        logMessage("Trying to restart browser in non-kiosk mode...");
        // This will only work if the browser was started with a script
        window.location.href = 'about:restart';
      } catch (e) {
        logMessage("Browser restart failed: " + e.message);
      }
    }, 2000);
  }

  function showKioskInfo() {
    const info = `
Kiosk Mode Information:
- Session: LXDE-pi-labwc
- Browser: Chromium with --kiosk flag
- Window Manager: labwc (lightweight)
- Fullscreen: ${document.fullscreenElement ? 'Yes' : 'No'}
- Window size: ${window.innerWidth}x${window.innerHeight}
- Screen size: ${window.screen.width}x${window.screen.height}

Solutions:
1. Remove --kiosk flag from startup script
2. Use --start-maximized instead
3. Add physical exit button
4. Use SSH to kill browser process

Current startup command:
/usr/bin/chromium-browser --kiosk --disable-restore-session-state
    `;
    alert(info);
  }

  function sendEscKey() {
    logMessage("Sending ESC key (should work since physical ESC works)...");
    
    try {
      // Send keydown event
      const escDownEvent = new KeyboardEvent("keydown", {
        key: "Escape",
        code: "Escape",
        keyCode: 27,
        which: 27,
        bubbles: true,
        cancelable: true,
        view: window
      });
      document.dispatchEvent(escDownEvent);
      logMessage("ESC keydown sent");
      
      // Send keyup event after a short delay
      setTimeout(() => {
        const escUpEvent = new KeyboardEvent("keyup", {
          key: "Escape",
          code: "Escape",
          keyCode: 27,
          which: 27,
          bubbles: true,
          cancelable: true,
          view: window
        });
        document.dispatchEvent(escUpEvent);
        logMessage("ESC keyup sent");
      }, 100);
      
    } catch (e) {
      logMessage("ESC key sending failed: " + e.message);
    }
  }

  function triggerXButton() {
    logMessage("Trying to trigger X button by mouse movement...");
    
    // Method 1: Move mouse to top of screen to trigger X button
    try {
      logMessage("Moving mouse to top of screen...");
      const mouseMoveEvent = new MouseEvent("mousemove", {
        bubbles: true,
        cancelable: true,
        view: window,
        clientX: window.innerWidth / 2,
        clientY: 5
      });
      document.dispatchEvent(mouseMoveEvent);
      logMessage("Mouse moved to top");
      
      // Wait a bit and then try to click where X button might appear
      setTimeout(() => {
        try {
          logMessage("Trying to click where X button might be...");
          const clickEvent = new MouseEvent("click", {
            bubbles: true,
            cancelable: true,
            view: window,
            clientX: window.innerWidth - 30,
            clientY: 15
          });
          document.dispatchEvent(clickEvent);
          logMessage("Click sent to X button area");
        } catch (e) {
          logMessage("X button click failed: " + e.message);
        }
      }, 500);
      
    } catch (e) {
      logMessage("Mouse movement failed: " + e.message);
    }
    
    // Method 2: Try to find and click any close button
    setTimeout(() => {
      try {
        logMessage("Looking for close buttons in DOM...");
        const closeButtons = document.querySelectorAll('button, a, div');
        for (let button of closeButtons) {
          const text = button.textContent || button.title || '';
          if (text.toLowerCase().includes('close') || 
              text.toLowerCase().includes('exit') || 
              text.toLowerCase().includes('x') ||
              button.className.toLowerCase().includes('close') ||
              button.id.toLowerCase().includes('close')) {
            logMessage("Found potential close button: " + text);
            button.click();
            break;
          }
        }
      } catch (e) {
        logMessage("Close button search failed: " + e.message);
      }
    }, 1000);
  }

  function tryAlternativeStartup() {
    logMessage("Trying to restart browser with alternative flags...");
    
    // Try to navigate to a special URL that might trigger restart
    try {
      // Method 1: Try chrome://restart
      window.location.href = 'chrome://restart';
      logMessage("Navigated to chrome://restart");
    } catch (e) {
      logMessage("chrome://restart failed: " + e.message);
      
      // Method 2: Try to reload with different parameters
      try {
        const currentUrl = window.location.href;
        const newUrl = currentUrl + (currentUrl.includes('?') ? '&' : '?') + 'exit_fullscreen=true';
        window.location.href = newUrl;
        logMessage("Reloaded with exit_fullscreen parameter");
      } catch (e2) {
        logMessage("Reload with parameter failed: " + e2.message);
      }
    }
  }

  function showStartupOptions() {
    const options = `
Alternative Chromium Startup Options:

1. Fullscreen ohne Kiosk:
/usr/bin/chromium-browser --start-fullscreen --disable-restore-session-state --disable-web-security

2. App-Modus (Fullscreen):
/usr/bin/chromium-browser --app=URL --disable-restore-session-state --disable-web-security

3. Maximiert + Auto-Fullscreen:
/usr/bin/chromium-browser --start-maximized --disable-restore-session-state --disable-web-security --auto-open-devtools-for-tabs

4. Kiosk mit Exit-Möglichkeit:
/usr/bin/chromium-browser --kiosk --disable-restore-session-state --disable-web-security --disable-features=VizDisplayCompositor --enable-features=OverlayScrollbar

5. Maximiert + JavaScript Fullscreen:
/usr/bin/chromium-browser --start-maximized --disable-restore-session-state --disable-web-security --allow-running-insecure-content

6. App-Modus mit URL:
/usr/bin/chromium-browser --app="$(cat /var/www/carambus/current/config/scoreboard_url)" --disable-restore-session-state

7. Fullscreen mit Exit-Key:
/usr/bin/chromium-browser --start-fullscreen --disable-restore-session-state --disable-web-security --disable-features=VizDisplayCompositor

8. Maximiert + Auto-Enter-Fullscreen:
/usr/bin/chromium-browser --start-maximized --disable-restore-session-state --disable-web-security --disable-features=VizDisplayCompositor

Empfehlung: Option 1 oder 7 testen!
    `;
    alert(options);
  }

  function tryEnterFullscreen() {
    logMessage("Trying to enter fullscreen mode programmatically...");
    
    try {
      // Method 1: Try standard fullscreen API
      if (document.documentElement.requestFullscreen) {
        document.documentElement.requestFullscreen();
        logMessage("Standard fullscreen API called");
      } else if (document.documentElement.webkitRequestFullscreen) {
        document.documentElement.webkitRequestFullscreen();
        logMessage("Webkit fullscreen API called");
      } else if (document.documentElement.mozRequestFullScreen) {
        document.documentElement.mozRequestFullScreen();
        logMessage("Mozilla fullscreen API called");
      } else if (document.documentElement.msRequestFullscreen) {
        document.documentElement.msRequestFullscreen();
        logMessage("MS fullscreen API called");
      } else {
        logMessage("No fullscreen API available");
      }
    } catch (e) {
      logMessage("Fullscreen API failed: " + e.message);
    }
    
    // Method 2: Try F11 key
    setTimeout(() => {
      try {
        logMessage("Trying F11 to enter fullscreen...");
        const f11Event = new KeyboardEvent("keydown", {
          key: "F11",
          code: "F11",
          keyCode: 122,
          which: 122,
          bubbles: true,
          cancelable: true,
          view: window
        });
        document.dispatchEvent(f11Event);
      } catch (e) {
        logMessage("F11 method failed: " + e.message);
      }
    }, 500);
  }

  function showCurrentStatus() {
    const status = `
Current Status Analysis:
- Browser: Chromium with --start-fullscreen
- Behavior: Like kiosk mode (only physical events work)
- JavaScript events: Blocked by browser security
- Physical ESC: Works
- Physical ALT+F4: Should work

SOLUTIONS (in order of recommendation):

1. APP MODE (Best):
   /usr/bin/chromium-browser --app="$(cat /var/www/carambus/current/config/scoreboard_url)" --disable-restore-session-state
   - Fullscreen without browser UI
   - ALT+F4 works to exit
   - No JavaScript restrictions

2. MAXIMIZED + JAVASCRIPT FULLSCREEN:
   /usr/bin/chromium-browser --start-maximized --disable-restore-session-state --disable-web-security
   - Starts maximized
   - JavaScript can control fullscreen
   - ESC works to exit

3. PHYSICAL EXIT BUTTON:
   - USB button or GPIO button
   - Sends ESC or ALT+F4
   - Most reliable solution

4. SSH EXIT SCRIPT:
   #!/bin/bash
   pkill chromium-browser
   sleep 2
   /usr/bin/chromium-browser --app="$(cat /var/www/carambus/current/config/scoreboard_url)" --disable-restore-session-state &

5. CRON AUTO-RESTART:
   0 */6 * * * pkill chromium-browser && sleep 5 && /usr/bin/chromium-browser --app="$(cat /var/www/carambus/current/config/scoreboard_url)" --disable-restore-session-state &

RECOMMENDATION: Try APP MODE first!
    `;
    alert(status);
  }

  function showAppModeSolutions() {
    const solutions = `
APP MODE WINDOW SIZING SOLUTIONS:

Problem: App mode shows narrow strip at top, needs mouse to resize

SOLUTIONS:

1. APP MODE WITH WINDOW SIZE:
   /usr/bin/chromium-browser --app="$(cat /var/www/carambus/current/config/scoreboard_url)" --window-size=1920,1080 --window-position=0,0 --disable-restore-session-state

2. APP MODE WITH SCREEN SIZE:
   /usr/bin/chromium-browser --app="$(cat /var/www/carambus/current/config/scoreboard_url)" --window-size=$(xrandr | grep '*' | awk '{print $1}' | cut -d'x' -f1),$(xrandr | grep '*' | awk '{print $1}' | cut -d'x' -f2) --window-position=0,0 --disable-restore-session-state

3. APP MODE + WINDOW MANAGER COMMANDS:
   #!/bin/bash
   /usr/bin/chromium-browser --app="$(cat /var/www/carambus/current/config/scoreboard_url)" --disable-restore-session-state &
   sleep 3
   wmctrl -r "Chromium" -b add,fullscreen
   # or
   xdotool search --name "Chromium" windowactivate && xdotool key F11

4. APP MODE + JAVASCRIPT FULLSCREEN:
   /usr/bin/chromium-browser --app="$(cat /var/www/carambus/current/config/scoreboard_url)" --start-maximized --disable-restore-session-state
   # Then use JavaScript to enter fullscreen

5. HYBRID APPROACH:
   /usr/bin/chromium-browser --start-maximized --disable-restore-session-state --disable-web-security --app="$(cat /var/www/carambus/current/config/scoreboard_url)"

6. WINDOW MANAGER CONFIG:
   # Add to ~/.config/labwc/rc.xml or similar
   <application name="chromium-browser">
     <fullscreen>yes</fullscreen>
   </application>

RECOMMENDATION: Try option 1 or 3!
    `;
    alert(solutions);
  }

  function showPanelHidingSolutions() {
    const solutions = `
SYSTEM PANEL HIDING SOLUTIONS:

Problem: System panel/taskbar remains visible, window can't go fullscreen

SOLUTIONS:

1. HIDE PANEL VIA AUTOSTART SCRIPT:
   #!/bin/bash
   # Hide panel before starting browser
   wmctrl -r "panel" -b add,hidden 2>/dev/null || true
   # or
   xdotool search --name "panel" windowunmap 2>/dev/null || true
   
   # Start browser
   /usr/bin/chromium-browser --app="$(cat /var/www/carambus/current/config/scoreboard_url)" --window-size=$(xrandr | grep '*' | awk '{print $1}' | cut -d'x' -f1),$(xrandr | grep '*' | awk '{print $1}' | cut -d'x' -f2) --window-position=0,0 --disable-restore-session-state

2. LABWC CONFIGURATION:
   # Edit ~/.config/labwc/rc.xml
   <application name="panel">
     <decor>no</decor>
     <skip_taskbar>yes</skip_taskbar>
     <skip_pager>yes</skip_pager>
   </application>
   
   <application name="chromium-browser">
     <fullscreen>yes</fullscreen>
     <decor>no</decor>
   </application>

3. LXDE PANEL CONFIG:
   # Edit ~/.config/lxpanel/LXDE-pi/panels/panel
   # Add: ToggleButton=0
   # Or disable panel completely

4. WINDOW MANAGER COMMANDS:
   #!/bin/bash
   # Kill panel process
   pkill lxpanel 2>/dev/null || true
   pkill lxpanelctl 2>/dev/null || true
   
   # Start browser
   /usr/bin/chromium-browser --app="$(cat /var/www/carambus/current/config/scoreboard_url)" --window-size=$(xrandr | grep '*' | awk '{print $1}' | cut -d'x' -f1),$(xrandr | grep '*' | awk '{print $1}' | cut -d'x' -f2) --window-position=0,0 --disable-restore-session-state

5. ALTERNATIVE: USE OPENBOX INSTEAD OF LABWC:
   # Install openbox
   sudo apt install openbox
   
   # Configure openbox to hide panel
   # Edit ~/.config/openbox/rc.xml

6. FULLSCREEN SCRIPT:
   #!/bin/bash
   # Hide panel
   wmctrl -r "panel" -b add,hidden 2>/dev/null || true
   
   # Start browser
   /usr/bin/chromium-browser --app="$(cat /var/www/carambus/current/config/scoreboard_url)" --disable-restore-session-state &
   
   # Wait and make fullscreen
   sleep 3
   wmctrl -r "Chromium" -b add,fullscreen

RECOMMENDATION: Try option 1 or 4 first!
    `;
    alert(solutions);
  }

  function showLXDESolutions() {
    const solutions = `
LXDE PANEL PERMANENT DISABLE SOLUTIONS:

Problem: lxpanel restarts automatically after being killed

PERMANENT SOLUTIONS:

1. DISABLE LXDE AUTOSTART:
   # Edit ~/.config/lxsession/LXDE-pi/autostart
   # Comment out or remove these lines:
   # @lxpanel --profile LXDE-pi
   # @pcmanfm --desktop --profile LXDE-pi
   
   # Add your browser startup instead:
   @/usr/local/bin/start-scoreboard.sh

2. DISABLE PANEL VIA CONFIG:
   # Edit ~/.config/lxpanel/LXDE-pi/panels/panel
   # Add at the top:
   ToggleButton=0
   # Or rename the file to disable it:
   mv ~/.config/lxpanel/LXDE-pi/panels/panel ~/.config/lxpanel/LXDE-pi/panels/panel.disabled

3. CREATE CUSTOM SESSION:
   # Create ~/.config/lxsession/LXDE-pi/desktop.conf
   [*]
   window_manager=labwc
   panel=
   
   # Create ~/.config/lxsession/LXDE-pi/autostart
   @/usr/local/bin/start-scoreboard.sh

4. SYSTEMD SERVICE APPROACH:
   # Create /etc/systemd/system/scoreboard.service
   [Unit]
   Description=Scoreboard Browser
   After=graphical-session.target
   
   [Service]
   Type=simple
   User=pi
   Environment=DISPLAY=:0
   ExecStartPre=/bin/bash -c "pkill lxpanel || true"
   ExecStart=/usr/local/bin/start-scoreboard.sh
   Restart=always
   
   [Install]
   WantedBy=graphical-session.target

5. LABWC CONFIGURATION:
   # Edit ~/.config/labwc/rc.xml
   <application name="lxpanel">
     <skip_taskbar>yes</skip_taskbar>
     <skip_pager>yes</skip_pager>
     <decor>no</decor>
   </application>
   
   <application name="panel">
     <skip_taskbar>yes</skip_taskbar>
     <skip_pager>yes</skip_pager>
     <decor>no</decor>
   </application>

6. ALTERNATIVE: MINIMAL SESSION:
   # Install minimal window manager
   sudo apt install openbox
   
   # Create ~/.xinitrc
   #!/bin/bash
   /usr/local/bin/start-scoreboard.sh &
   exec openbox-session

RECOMMENDATION: Try option 1 or 2 first!
    `;
    alert(solutions);
  }

  function showTemporaryExitSolutions() {
    const solutions = `
TEMPORARY EXIT SOLUTIONS:

Goal: Exit scoreboard temporarily to access desktop, then return

SOLUTIONS:

1. APP MODE WITH EXIT BUTTON:
   /usr/bin/chromium-browser --app="$(cat /var/www/carambus/current/config/scoreboard_url)" --window-size=$(xrandr | grep '*' | awk '{print $1}' | cut -d'x' -f1),$(xrandr | grep '*' | awk '{print $1}' | cut -d'x' -f2) --window-position=0,0 --disable-restore-session-state
   
   - X button in top-right corner works
   - ALT+F4 works to close
   - Returns to desktop with panel visible

2. MAXIMIZED MODE WITH EXIT:
   /usr/bin/chromium-browser --start-maximized --disable-restore-session-state --disable-web-security
   
   - ESC exits fullscreen
   - ALT+F4 closes browser
   - Panel remains visible

3. HYBRID APPROACH:
   /usr/bin/chromium-browser --start-maximized --disable-restore-session-state --disable-web-security --app="$(cat /var/www/carambus/current/config/scoreboard_url)"
   
   - Combines app mode with maximized
   - Multiple exit options

4. DESKTOP ACCESS SCRIPT:
   #!/bin/bash
   # Create /usr/local/bin/exit-scoreboard.sh
   pkill chromium-browser
   sleep 2
   # Optional: Start file manager or terminal
   pcmanfm &
   
   # Create /usr/local/bin/restart-scoreboard.sh
   pkill pcmanfm 2>/dev/null || true
   /usr/local/bin/start-scoreboard.sh

5. KEYBOARD SHORTCUTS:
   # Add to ~/.config/openbox/rc.xml or labwc config
   <keybind key="F12">
     <action name="Execute">
       <command>/usr/local/bin/exit-scoreboard.sh</command>
     </action>
   </keybind>
   
   <keybind key="F11">
     <action name="Execute">
       <command>/usr/local/bin/restart-scoreboard.sh</command>
     </action>
   </keybind>

6. TOUCHSCREEN EXIT BUTTON:
   # Add a small exit button to your scoreboard page
   # That calls: window.close() or navigates to desktop

7. SSH EXIT COMMANDS:
   # From another computer:
   ssh pi@scoreboard "pkill chromium-browser"
   ssh pi@scoreboard "/usr/local/bin/restart-scoreboard.sh"

RECOMMENDATION: Try option 1 (App Mode) first!
    `;
    alert(solutions);
  }

  function showTrueFullscreenSolutions() {
    const solutions = `
TRUE FULLSCREEN SOLUTIONS (No bars/lines):

Goal: True fullscreen without any UI elements, but with exit capability

SOLUTIONS:

1. PANEL HIDE/SHOW SCRIPT:
   #!/bin/bash
   # /usr/local/bin/start-scoreboard.sh
   
   # Hide panel before starting
   wmctrl -r "panel" -b add,hidden 2>/dev/null || true
   wmctrl -r "lxpanel" -b add,hidden 2>/dev/null || true
   
   # Start browser in true fullscreen
   /usr/bin/chromium-browser --start-fullscreen --disable-restore-session-state --disable-web-security --app="$(cat /var/www/carambus/current/config/scoreboard_url)" &
   
   # Wait for browser to start
   sleep 3
   
   # Make sure it's fullscreen
   wmctrl -r "Chromium" -b add,fullscreen 2>/dev/null || true

2. EXIT SCRIPT WITH PANEL RESTORE:
   #!/bin/bash
   # /usr/local/bin/exit-scoreboard.sh
   
   # Kill browser
   pkill chromium-browser
   sleep 2
   
   # Show panel again
   wmctrl -r "panel" -b remove,hidden 2>/dev/null || true
   wmctrl -r "lxpanel" -b remove,hidden 2>/dev/null || true
   
   # Start desktop environment
   pcmanfm --desktop &

3. RESTART SCRIPT:
   #!/bin/bash
   # /usr/local/bin/restart-scoreboard.sh
   
   # Kill desktop apps
   pkill pcmanfm 2>/dev/null || true
   
   # Restart scoreboard
   /usr/local/bin/start-scoreboard.sh

4. LABWC CONFIGURATION:
   # Edit ~/.config/labwc/rc.xml
   <application name="chromium-browser">
     <fullscreen>yes</fullscreen>
     <decor>no</decor>
     <skip_taskbar>yes</skip_taskbar>
   </application>
   
   <application name="panel">
     <skip_taskbar>yes</skip_taskbar>
     <skip_pager>yes</skip_pager>
   </application>

5. KEYBOARD SHORTCUTS:
   # Add to ~/.config/labwc/rc.xml
   <keybind key="F12">
     <action name="Execute">
       <command>/usr/local/bin/exit-scoreboard.sh</command>
     </action>
   </keybind>
   
   <keybind key="F11">
     <action name="Execute">
       <command>/usr/local/bin/restart-scoreboard.sh</command>
     </action>
   </keybind>

6. SYSTEMD SERVICE WITH PANEL CONTROL:
   # /etc/systemd/system/scoreboard.service
   [Unit]
   Description=Scoreboard Browser
   After=graphical-session.target
   
   [Service]
   Type=simple
   User=pi
   Environment=DISPLAY=:0
   ExecStartPre=/bin/bash -c "wmctrl -r panel -b add,hidden 2>/dev/null || true"
   ExecStart=/usr/local/bin/start-scoreboard.sh
   ExecStop=/bin/bash -c "wmctrl -r panel -b remove,hidden 2>/dev/null || true"
   Restart=no
   
   [Install]
   WantedBy=graphical-session.target

7. TOUCHSCREEN EXIT BUTTON:
   # Add to your scoreboard page
   <button onclick="window.close()">Exit to Desktop</button>
   # or
   <button onclick="location.href='file:///home/pi/Desktop'">Exit to Desktop</button>

WORKFLOW:
1. Panel wird versteckt
2. Browser startet in echtem Fullscreen
3. F12 oder Touch-Button zum Exit
4. Panel wird wieder sichtbar
5. Desktop ist zugänglich
6. F11 oder Script zum Restart

RECOMMENDATION: Try option 1 first!
    `;
    alert(solutions);
  }

  function showAutostartConfiguration() {
    const config = `
AUTOSTART CONFIGURATION STEPS:

To make scoreboard start automatically after boot:

STEP 1: CREATE STARTUP SCRIPT
# Create the startup script
sudo nano /usr/local/bin/start-scoreboard.sh

# Add this content:
#!/bin/bash
# Hide panel before starting
wmctrl -r "panel" -b add,hidden 2>/dev/null || true
wmctrl -r "lxpanel" -b add,hidden 2>/dev/null || true

# Start browser in true fullscreen
/usr/bin/chromium-browser --start-fullscreen --disable-restore-session-state --disable-web-security --app="$(cat /var/www/carambus/current/config/scoreboard_url)" &

# Wait for browser to start
sleep 3

# Make sure it's fullscreen
wmctrl -r "Chromium" -b add,fullscreen 2>/dev/null || true

# Make it executable
sudo chmod +x /usr/local/bin/start-scoreboard.sh

STEP 2: CREATE EXIT SCRIPT
sudo nano /usr/local/bin/exit-scoreboard.sh

# Add this content:
#!/bin/bash
# Kill browser
pkill chromium-browser
sleep 2

# Show panel again
wmctrl -r "panel" -b remove,hidden 2>/dev/null || true
wmctrl -r "lxpanel" -b remove,hidden 2>/dev/null || true

# Start desktop environment
pcmanfm --desktop &

# Make it executable
sudo chmod +x /usr/local/bin/exit-scoreboard.sh

STEP 3: CREATE RESTART SCRIPT
sudo nano /usr/local/bin/restart-scoreboard.sh

# Add this content:
#!/bin/bash
# Kill desktop apps
pkill pcmanfm 2>/dev/null || true

# Restart scoreboard
/usr/local/bin/start-scoreboard.sh

# Make it executable
sudo chmod +x /usr/local/bin/restart-scoreboard.sh

STEP 4: CONFIGURE AUTOSTART
# Edit LXDE autostart file
nano ~/.config/lxsession/LXDE-pi/autostart

# Comment out or remove these lines:
# @lxpanel --profile LXDE-pi
# @pcmanfm --desktop --profile LXDE-pi

# Add your scoreboard startup:
@/usr/local/bin/start-scoreboard.sh

STEP 5: ADD KEYBOARD SHORTCUTS (Optional)
# Edit labwc configuration
nano ~/.config/labwc/rc.xml

# Add inside <keyboard> section:
<keybind key="F12">
  <action name="Execute">
    <command>/usr/local/bin/exit-scoreboard.sh</command>
  </action>
</keybind>

<keybind key="F11">
  <action name="Execute">
    <command>/usr/local/bin/restart-scoreboard.sh</command>
  </action>
</keybind>

STEP 6: TEST THE SETUP
# Test the startup script manually
/usr/local/bin/start-scoreboard.sh

# Test exit script
/usr/local/bin/exit-scoreboard.sh

# Test restart script
/usr/local/bin/restart-scoreboard.sh

STEP 7: REBOOT TO TEST
sudo reboot

# After reboot, scoreboard should start automatically in fullscreen

TROUBLESHOOTING:
- If it doesn't work, check logs: journalctl -u lxsession
- If panel doesn't hide: install wmctrl: sudo apt install wmctrl
- If browser doesn't start: check URL in config file
- If fullscreen doesn't work: check labwc configuration

RECOMMENDATION: Follow steps 1-7 in order!
    `;
    alert(config);
  }

  function tryResizeWindow() {
    logMessage("Trying to resize window programmatically...");
    
    // Method 1: Try to resize window via window.resizeTo
    try {
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
      logMessage("Screen size: " + screenWidth + "x" + screenHeight);
      
      window.resizeTo(screenWidth, screenHeight);
      window.moveTo(0, 0);
      logMessage("Window resized to screen size");
    } catch (e) {
      logMessage("Window resize failed: " + e.message);
    }
    
    // Method 2: Try to enter fullscreen via API
    setTimeout(() => {
      try {
        logMessage("Trying to enter fullscreen after resize...");
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen();
        } else if (document.documentElement.webkitRequestFullscreen) {
          document.documentElement.webkitRequestFullscreen();
        }
        logMessage("Fullscreen API called after resize");
      } catch (e) {
        logMessage("Fullscreen after resize failed: " + e.message);
      }
    }, 500);
    
    // Method 3: Try to click on maximize button area
    setTimeout(() => {
      try {
        logMessage("Trying to click maximize button area...");
        const maximizeClick = new MouseEvent("click", {
          bubbles: true,
          cancelable: true,
          view: window,
          clientX: window.innerWidth - 30,
          clientY: 15
        });
        document.dispatchEvent(maximizeClick);
        logMessage("Maximize button click sent");
      } catch (e) {
        logMessage("Maximize button click failed: " + e.message);
      }
    }, 1000);
  }

  document.addEventListener('turbo:load', function () {
    console.log('Window.hotkeys in view:', window.hotkeys); // Check availability
    if (!window.hotkeys) {
      console.error('Hotkeys not available!');
      return;
    }
    let tabbed_elements = document.querySelectorAll('a[tabindex="1"]')
    let tabbed_keys = []
    for (let i = 0; i < tabbed_elements.length; i++) {
      tabbed_keys[i] = tabbed_elements[i].getAttribute("id")
    }
    if (tabbed_keys.length > 0) {
      let current_element = tabbed_keys[0]
      document.getElementById(current_element).focus();
    }
    // backspace, tab, clear, enter, return, esc, escape, space, up, down, left, right, home, end, pageup, pagedown, del, delete and f1 through f19
    window.hotkeys('*', function (event) {
    // Prevent the default refresh event under WINDOWS system

      //console.log(hotkeys.getPressedKeyCodes());
      //alert('you pressed ' + hotkeys.getPressedKeyCodes());
      const keyMap = {
        33: "key_a", //pointer left
        37: "key_a", //arrow left
        34: "key_b", //pointer right
        39: "key_b", //arrow right
        66: "key_c", //pointer up
        38: "key_c", //arrow up
        116: "key_d", //pointer down
        27: "key_d", //pointer down
        40: "key_d", //arrow down
        13: "key_d", //return
      }
      let tabbed_elements = document.querySelectorAll('a[tabindex="1"]')

      let tabbed_keys = []
      for (let i = 0; i < tabbed_elements.length; i++) {
        tabbed_keys[i] = tabbed_elements[i].getAttribute("id")
      }

      let current_element = document.activeElement.getAttribute("id")
      console.log("active: " + current_element);
      if (current_element == null) {
        current_element = tabbed_keys[0];
        console.log("active now: " + current_element);
        document.getElementById(current_element).focus();
      }

      if (event.key in keyMap) {
        let key = keyMap[event.key];
        if (key === "key_c") {
          window.history.back();
        }
        if (key === "key_b") {
          current_element = document.activeElement.getAttribute("id")
          for (let i = 0; i < tabbed_keys.length; i++) {
            if (tabbed_keys[i] === current_element) {
              let ff = i + 1;
              if (ff >= tabbed_keys.length) ff = 0;
              console.log("active becomes (a): " + tabbed_keys[ff]);
              document.getElementById(tabbed_keys[ff]).focus();
              break;
            }
          }
        }
        if (key === "key_a") {
          let current_element = document.activeElement.getAttribute("id");
          for (let i = 0; i < tabbed_keys.length; i++) {
            if (tabbed_keys[i] === current_element) {
              let ff = i - 1;
              if (ff < 0) ff = tabbed_keys.length - 1;
              console.log("active becomes (a): " + tabbed_keys[ff]);
              document.getElementById(tabbed_keys[ff]).focus();
              break;
            }
          }
        }
        if (key === "key_d") {
          console.log("activate: " + document.activeElement.getAttribute("id"));
          document.activeElement.click();
        }
      }
      event.preventDefault();
      return true
    });
  });
</script>
<div style="z-index:900" class="hidden opacity-70 fixed inset-0 bg-black" id="modal-new-reservation-bg"></div>
<div style="z-index:910" class="hidden overflow-x-hidden overflow-y-auto fixed inset-0 outline-none focus:outline-none justify-center" id="modal-new-reservation">
  <div id="new_reservation_modal_setup__2" class="border-2 border-gray-500 rounded-lg shadow-lg relative flex flex-col p-10 w-5/6 dark:text-gray-200 bg-white dark:bg-black  outline-none focus:outline-none">
    <div class="flex flex-col">
      <h2 class="flex mb-5">Neue Tischreservierung <%= @location.name %></h2>
      <div class="flex justify-around w-full text-2vw">
        <%= form_with(model: @location, method: :post, url: { action: "create_event" }) do |form| %>
          <%= hidden_field_tag :location_id, @location.id %>
          <%= render "error_messages", resource: form.object %>
          <div class="form-group flex">
            <%= form.text_field :summary, autocomplete: "off", class: "form-control text-2vw", style: "width: 400px", placeholder: "Event Titel, z.B. \"T4 Peter+Mike\"" %>
          </div>
          <div class="form-group flex items-center">
            <input type="date" name="location[date]" id="location_date">
            &nbsp;&nbsp;&nbsp;&nbsp;
            <input type="time" name="location[start_time]" id="location-start-time" class="bg-gray-50 border leading-none border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block ml-10 p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500" min="00:00" value="19:00" required/>
            &nbsp;-&nbsp;
            <input type="time" name="location[end_time]" id="location-end-time" class="bg-gray-50 border leading-none border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500" min="00:00" value="23:00" required/>
          </div>
          <div class="form-group">
            <%= custom_link_to t('back'), "javascript:set_new_reservation_modal()", data: { turbolinks: false }, class: "dark:text-white focus:outline-none focus:ring-8 focus:ring-green-500 focus:ring-opacity-90 border-0 btn btn-primary text-2vw", id: "cancel", tabindex: "1" %>

            <%= form.submit t('save'), class: "btn btn-primary text-2vw" %>
          </div>
          <p class="text-1-5vw leading-6">
            Die Belegung der Tische, das Turnier, die Teilnehmer,
            sowie eine Angabe zur automatischen Heizungssteuerung,
            wird durch eine Namenskonvention im Titel festgelegt.
          </p>
          <p class="text-1-5vw leading-6">
            Der Titel setzt sich zusammen aus einer mit Kommas getrennten
            Liste von Tischbereichen (z.B. T5 oder T6-T8), gefolgt von einem
            Lehrzeichen und dem Eventtitel oder den Spielernamen, Also z.B.
            "Clubabend" oder "NDM Cadre 35/2" oder "Lothar + Gernot".
            Am Ende kann ein Ausrufungszeichen (!) gesetzt werden um zu
            verhindern, dass Heizungen bei Nichtbenutzung während der
            Reservierung abgeschaltet werden.
            Termineinträge, die sich nicht an diese Namenskonvention
            halten und auch nicht mit einem Label wie "info:" oder "BGH:" beginnen,
            werden automatisch gelöscht.
          </p>
        <% end %>
      </div>
    </div>
  </div>
</div>
<div class="w-1/12 grid grid-cols-2 gap-4 mr-4 fixed text-gray-300 hover:text-black text-2vw font-bold" style="right: 10px; top: -10px;">
  <%= custom_link_to scoreboard_location_path(@location.md5, sb_state: "table_scores", :"data-turbo" => false) do %>
    <%= render_svg "icons/information-outline", styles: "responsive-svg fill-current icon-lg m-4 text-white inline-block", title: "home" %>
  <% end %>
  <%= custom_link_to scoreboard_location_path(@location.md5, sb_state: "welcome", :"data-turbo" => false) do %>
    <%= render_svg "icons/home", styles: "responsive-svg fill-current icon-lg m-4 text-white inline-block", title: "home" %>
  <% end %>
</div>
<div class="p-7 lg:p-14 text-gray-200 w-full m-auto flex items-center flex-col bg-cover h-screen bg-center bg-no-repeat" style="background-image: url('/bg_pool2-.jpg')">
  <h1 style="text-shadow: 2px 2px #000000" class="flex text-gray-200 text-3vw"><%= t('home.index.reservation') %>
    - <%= @location.name %></h1>
  <%- if @location.present? %>
    <%- table_status = JSON.parse(File.read(File.join(Rails.root, 'log', 'events'))) rescue [] %>
    <div class="w-3/5 h-2/5 overflow-y-auto mt-5">
      <pre><%= table_status.join("\n") %></pre>
    </div>
    <p>
      <%= custom_link_to "Neue Reservierung", "javascript:new_reservation_mode()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-green-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-primary text-2vw", id: "cancel", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Exit Kiosk Mode", "javascript:open_kiosk_keyboard()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-red-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-danger text-2vw", id: "exit_kiosk", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Show Debug Logs", "javascript:showDebugLogs()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-blue-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-info text-2vw", id: "show_logs", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Download Debug Logs", "javascript:downloadDebugLogs()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-purple-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-secondary text-2vw", id: "download_logs", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Test Kiosk Exit", "javascript:fireAltSpaceEvent()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-yellow-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-warning text-2vw", id: "test_exit", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Try Linux Window Management", "javascript:tryLinuxWindowManagement()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-purple-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-secondary text-2vw", id: "try_linux_wm", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Show Kiosk Info", "javascript:showKioskInfo()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-orange-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-warning text-2vw", id: "kiosk_info", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Send ESC Key (Physical ESC)", "javascript:sendEscKey()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-purple-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-secondary text-2vw", id: "send_esc_key", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Trigger X Button", "javascript:triggerXButton()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-red-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-danger text-2vw", id: "trigger_x_button", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Try Alternative Startup", "javascript:tryAlternativeStartup()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-purple-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-secondary text-2vw", id: "try_alternative_startup", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Show Startup Options", "javascript:showStartupOptions()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-blue-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-info text-2vw", id: "show_startup_options", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Try Enter Fullscreen", "javascript:tryEnterFullscreen()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-green-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-success text-2vw", id: "try_fullscreen", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Show Current Status", "javascript:showCurrentStatus()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-orange-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-warning text-2vw", id: "show_status", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Show App Mode Solutions", "javascript:showAppModeSolutions()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-purple-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-secondary text-2vw", id: "show_app_solutions", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Show Panel Hiding Solutions", "javascript:showPanelHidingSolutions()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-blue-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-info text-2vw", id: "show_panel_hiding_solutions", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Try Resize Window", "javascript:tryResizeWindow()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-blue-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-info text-2vw", id: "try_resize_window", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Show LXDE Solutions", "javascript:showLXDESolutions()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-purple-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-secondary text-2vw", id: "show_lxde_solutions", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Show Temporary Exit Solutions", "javascript:showTemporaryExitSolutions()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-yellow-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-warning text-2vw", id: "show_temp_exit_solutions", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Show True Fullscreen Solutions", "javascript:showTrueFullscreenSolutions()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-purple-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-secondary text-2vw", id: "show_true_fullscreen_solutions", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Show Autostart Configuration", "javascript:showAutostartConfiguration()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-purple-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-secondary text-2vw", id: "show_autostart_config", tabindex: "1" %>
    </p>
    <p class="w-3/4 mt-5">
      Reservierungen können direkt hier oder im Google Kalender "BC Wedel" gemacht werden.
      Für den Zugang zum Google Kalender bitte email an gernot.ullrich@gmail.com oder wcauel@gmail.com.
      Es ist dafür eine @gmail.com eMail notwendig. Korrekturen sind derzeit nur im Google Kalender möglich.<br/>
      Die Heizungen werden entsprechend dieser Reservierungen geschaltet (zwei bzw. drei (gr. Tische) Stunden vor Terminbeginn).
    </p>
  <%- end %>
</div>
