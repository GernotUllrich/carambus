<!--suppress RubyScope, RubyScope, RubyScope -->
<!--suppress RubyScope, RubyScope, RubyScope -->
<!--<script src="https://unpkg.com/hotkeys-js/dist/hotkeys.js"></script>-->
<style>
    .responsive-svg {
        width: 100%;
        height: auto;
    }
    
    /* Kiosk Keyboard Styles */
    .kiosk-keyboard {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: #2d3748;
        padding: 20px;
        z-index: 1000;
        display: none;
    }
    
    .kiosk-keyboard.show {
        display: block;
    }
    
    .kiosk-keyboard .keyboard__keys {
        display: flex;
        justify-content: center;
        gap: 10px;
        flex-wrap: wrap;
    }
    
    .kiosk-keyboard .keyboard__key {
        padding: 15px 20px;
        border: none;
        border-radius: 8px;
        font-size: 18px;
        font-weight: bold;
        cursor: pointer;
        min-width: 80px;
        text-align: center;
    }
    
    .kiosk-keyboard .keyboard__key--wide {
        min-width: 120px;
    }
    
    .kiosk-keyboard .keyboard__key--extra-wide {
        min-width: 200px;
    }
    
    .kiosk-keyboard .keyboard__key--dark {
        background: #e53e3e;
        color: white;
    }
    
    .kiosk-keyboard .keyboard__key--activatable {
        background: #4a5568;
        color: white;
    }
    
    .kiosk-keyboard .keyboard__key--active {
        background: #2d3748;
    }
</style>
<!--<script src="/hotkeys.js"></script>-->
<script src="/onscreen-keyboard.js?v=<%= Time.current.to_i %>"></script>
<script type="text/javascript">

  function new_reservation_mode() {
    set_new_reservation_modal();
  }

  function set_new_reservation_modal() {
    document.getElementById("modal-new-reservation").classList.toggle("hidden");
    document.getElementById("modal-new-reservation" + "-bg").classList.toggle("hidden");
    document.getElementById("modal-new-reservation").classList.toggle("flex");
    document.getElementById("modal-new-reservation" + "-bg").classList.toggle("flex");
  }

  function open_kiosk_keyboard() {
    logMessage("Opening kiosk keyboard...");
    logMessage("Keyboard object available: " + (typeof Keyboard !== 'undefined'));
    
    if (typeof Keyboard !== 'undefined' && Keyboard._setupKeyboard) {
      logMessage("Using main keyboard with kiosk layout");
      Keyboard._setupKeyboard("kiosk");
      Keyboard.open("", null, null);
    } else {
      logMessage("Using fallback kiosk keyboard");
      showFallbackKioskKeyboard();
    }
  }

  function showFallbackKioskKeyboard() {
    logMessage("Creating fallback kiosk keyboard...");
    
    // Create fallback kiosk keyboard if it doesn't exist
    let kioskKeyboard = document.getElementById('fallback-kiosk-keyboard');
    if (!kioskKeyboard) {
      logMessage("Building new fallback keyboard...");
      kioskKeyboard = document.createElement('div');
      kioskKeyboard.id = 'fallback-kiosk-keyboard';
      kioskKeyboard.className = 'kiosk-keyboard';
      kioskKeyboard.innerHTML = `
        <div class="keyboard__keys">
          <button type="button" class="keyboard__key keyboard__key--wide keyboard__key--activatable" id="alt-key">ALT</button>
          <button type="button" class="keyboard__key keyboard__key--extra-wide" id="space-key">
            <i class="material-icons">space_bar</i>
          </button>
          <button type="button" class="keyboard__key keyboard__key--wide keyboard__key--dark" id="exit-kiosk-key">EXIT KIOSK</button>
          <button type="button" class="keyboard__key keyboard__key--wide keyboard__key--dark" id="close-kiosk-key">CLOSE</button>
          <button type="button" class="keyboard__key keyboard__key--wide" id="debug-key" style="background: #805ad5; color: white;">DEBUG</button>
          <button type="button" class="keyboard__key keyboard__key--wide" id="logs-key" style="background: #38a169; color: white;">LOGS</button>
        </div>
      `;
      document.body.appendChild(kioskKeyboard);
      
      // Add event listeners
      let altPressed = false;
      
      document.getElementById('alt-key').addEventListener('click', function() {
        logMessage("ALT key clicked, current state: " + altPressed);
        altPressed = !altPressed;
        this.classList.toggle('keyboard__key--active', altPressed);
        this.style.backgroundColor = altPressed ? '#2d3748' : '#4a5568';
        logMessage("ALT key state changed to: " + altPressed);
      });
      
      document.getElementById('space-key').addEventListener('click', function() {
        logMessage("SPACE key clicked, ALT pressed: " + altPressed);
        if (altPressed) {
          logMessage("ALT+SPACE combination triggered");
          fireAltSpaceEvent();
          altPressed = false;
          document.getElementById('alt-key').classList.remove('keyboard__key--active');
          document.getElementById('alt-key').style.backgroundColor = '#4a5568';
        } else {
          logMessage("SPACE clicked without ALT");
        }
      });
      
      document.getElementById('exit-kiosk-key').addEventListener('click', function() {
        logMessage("EXIT KIOSK button clicked");
        fireAltSpaceEvent();
      });
      
      document.getElementById('close-kiosk-key').addEventListener('click', function() {
        logMessage("CLOSE button clicked");
        kioskKeyboard.classList.remove('show');
      });
      
      document.getElementById('debug-key').addEventListener('click', function() {
        logMessage("DEBUG button clicked");
        logMessage("Current window properties:");
        logMessage("- document.fullscreenElement: " + document.fullscreenElement);
        logMessage("- window.innerHeight: " + window.innerHeight);
        logMessage("- window.innerWidth: " + window.innerWidth);
        logMessage("- window.screen.height: " + window.screen.height);
        logMessage("- window.screen.width: " + window.screen.width);
        logMessage("- navigator.userAgent: " + navigator.userAgent.substring(0, 50) + "...");
        
        // Try to detect if we're in kiosk mode
        const isKiosk = window.innerHeight === window.screen.height && window.innerWidth === window.screen.width;
        logMessage("Detected kiosk mode: " + isKiosk);
        
        // Show alert with debug info
        alert(`Debug Info:
- Fullscreen: ${document.fullscreenElement ? 'Yes' : 'No'}
- Window size: ${window.innerWidth}x${window.innerHeight}
- Screen size: ${window.screen.width}x${window.screen.height}
- Kiosk detected: ${isKiosk}
- User Agent: ${navigator.userAgent.substring(0, 50)}...`);
      });
      
      document.getElementById('logs-key').addEventListener('click', function() {
        showDebugLogs();
      });
      
      logMessage("Fallback keyboard event listeners added");
    }
    
    kioskKeyboard.classList.add('show');
    logMessage("Fallback keyboard shown");
  }

  function fireAltSpaceEvent() {
    logMessage("Firing ALT+SPACE event...");
    
    // Method 1: Try direct window.focus() first (sometimes works)
    try {
      window.focus();
      logMessage("Window focus attempted");
    } catch (e) {
      logMessage("Window focus failed: " + e.message);
    }
    
    // Method 2: Try to trigger window menu
    try {
      // Create a more aggressive ALT+SPACE event
      const altDownEvent = new KeyboardEvent("keydown", {
        key: "Alt",
        code: "AltLeft",
        keyCode: 18,
        which: 18,
        altKey: true,
        bubbles: true,
        cancelable: true,
        view: window,
        composed: true
      });

      const spaceDownEvent = new KeyboardEvent("keydown", {
        key: " ",
        code: "Space",
        keyCode: 32,
        which: 32,
        altKey: true,
        bubbles: true,
        cancelable: true,
        view: window,
        composed: true
      });

      const spaceUpEvent = new KeyboardEvent("keyup", {
        key: " ",
        code: "Space",
        keyCode: 32,
        which: 32,
        altKey: true,
        bubbles: true,
        cancelable: true,
        view: window,
        composed: true
      });

      const altUpEvent = new KeyboardEvent("keyup", {
        key: "Alt",
        code: "AltLeft",
        keyCode: 18,
        which: 18,
        altKey: false,
        bubbles: true,
        cancelable: true,
        view: window,
        composed: true
      });

      // Dispatch events in sequence with longer delays
      logMessage("Dispatching ALT+SPACE events...");
      document.dispatchEvent(altDownEvent);
      setTimeout(() => {
        document.dispatchEvent(spaceDownEvent);
        setTimeout(() => {
          document.dispatchEvent(spaceUpEvent);
          setTimeout(() => {
            document.dispatchEvent(altUpEvent);
            logMessage("ALT+SPACE events completed");
          }, 100);
        }, 100);
      }, 100);
    } catch (e) {
      logMessage("Method 2 failed: " + e.message);
    }
    
    // Method 3: Try F11 to toggle fullscreen
    setTimeout(() => {
      try {
        logMessage("Trying F11 to exit fullscreen...");
        const f11Event = new KeyboardEvent("keydown", {
          key: "F11",
          code: "F11",
          keyCode: 122,
          which: 122,
          bubbles: true,
          cancelable: true,
          view: window
        });
        document.dispatchEvent(f11Event);
      } catch (e) {
        logMessage("F11 method failed: " + e.message);
      }
    }, 500);
    
    // Method 4: Try ESC key
    setTimeout(() => {
      try {
        logMessage("Trying ESC key...");
        const escEvent = new KeyboardEvent("keydown", {
          key: "Escape",
          code: "Escape",
          keyCode: 27,
          which: 27,
          bubbles: true,
          cancelable: true,
          view: window
        });
        document.dispatchEvent(escEvent);
      } catch (e) {
        logMessage("ESC method failed: " + e.message);
      }
    }, 1000);
    
    // Method 5: Try to open browser menu programmatically
    setTimeout(() => {
      try {
        logMessage("Trying to open browser menu...");
        // Try to trigger right-click context menu
        const contextMenuEvent = new MouseEvent("contextmenu", {
          bubbles: true,
          cancelable: true,
          view: window,
          clientX: 10,
          clientY: 10
        });
        document.dispatchEvent(contextMenuEvent);
      } catch (e) {
        logMessage("Context menu method failed: " + e.message);
      }
    }, 1500);
    
    logMessage("All exit methods attempted");
  }

  // Simple logging function that saves to localStorage and shows in alert
  function logMessage(message) {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = `[${timestamp}] ${message}`;
    
    // Save to localStorage
    let logs = JSON.parse(localStorage.getItem('kioskDebugLogs') || '[]');
    logs.push(logEntry);
    if (logs.length > 50) logs = logs.slice(-50); // Keep only last 50 entries
    localStorage.setItem('kioskDebugLogs', JSON.stringify(logs));
    
    // Also log to console if available
    console.log(logEntry);
  }

  function showDebugLogs() {
    const logs = JSON.parse(localStorage.getItem('kioskDebugLogs') || '[]');
    if (logs.length === 0) {
      alert("No debug logs found. Try clicking 'Exit Kiosk Mode' first.");
      return;
    }
    
    const logText = logs.slice(-10).join('\n'); // Show last 10 entries
    alert("Last 10 Debug Logs:\n\n" + logText);
  }

  function clearDebugLogs() {
    localStorage.removeItem('kioskDebugLogs');
    alert("Debug logs cleared!");
  }

  document.addEventListener('turbo:load', function () {
    console.log('Window.hotkeys in view:', window.hotkeys); // Check availability
    if (!window.hotkeys) {
      console.error('Hotkeys not available!');
      return;
    }
    let tabbed_elements = document.querySelectorAll('a[tabindex="1"]')
    let tabbed_keys = []
    for (let i = 0; i < tabbed_elements.length; i++) {
      tabbed_keys[i] = tabbed_elements[i].getAttribute("id")
    }
    if (tabbed_keys.length > 0) {
      let current_element = tabbed_keys[0]
      document.getElementById(current_element).focus();
    }
    // backspace, tab, clear, enter, return, esc, escape, space, up, down, left, right, home, end, pageup, pagedown, del, delete and f1 through f19
    window.hotkeys('*', function (event) {
    // Prevent the default refresh event under WINDOWS system

      //console.log(hotkeys.getPressedKeyCodes());
      //alert('you pressed ' + hotkeys.getPressedKeyCodes());
      const keyMap = {
        33: "key_a", //pointer left
        37: "key_a", //arrow left
        34: "key_b", //pointer right
        39: "key_b", //arrow right
        66: "key_c", //pointer up
        38: "key_c", //arrow up
        116: "key_d", //pointer down
        27: "key_d", //pointer down
        40: "key_d", //arrow down
        13: "key_d", //return
      }
      let tabbed_elements = document.querySelectorAll('a[tabindex="1"]')

      let tabbed_keys = []
      for (let i = 0; i < tabbed_elements.length; i++) {
        tabbed_keys[i] = tabbed_elements[i].getAttribute("id")
      }

      let current_element = document.activeElement.getAttribute("id")
      console.log("active: " + current_element);
      if (current_element == null) {
        current_element = tabbed_keys[0];
        console.log("active now: " + current_element);
        document.getElementById(current_element).focus();
      }

      if (event.key in keyMap) {
        let key = keyMap[event.key];
        if (key === "key_c") {
          window.history.back();
        }
        if (key === "key_b") {
          current_element = document.activeElement.getAttribute("id")
          for (let i = 0; i < tabbed_keys.length; i++) {
            if (tabbed_keys[i] === current_element) {
              let ff = i + 1;
              if (ff >= tabbed_keys.length) ff = 0;
              console.log("active becomes (a): " + tabbed_keys[ff]);
              document.getElementById(tabbed_keys[ff]).focus();
              break;
            }
          }
        }
        if (key === "key_a") {
          let current_element = document.activeElement.getAttribute("id");
          for (let i = 0; i < tabbed_keys.length; i++) {
            if (tabbed_keys[i] === current_element) {
              let ff = i - 1;
              if (ff < 0) ff = tabbed_keys.length - 1;
              console.log("active becomes (a): " + tabbed_keys[ff]);
              document.getElementById(tabbed_keys[ff]).focus();
              break;
            }
          }
        }
        if (key === "key_d") {
          console.log("activate: " + document.activeElement.getAttribute("id"));
          document.activeElement.click();
        }
      }
      event.preventDefault();
      return true
    });
  });
</script>
<div style="z-index:900" class="hidden opacity-70 fixed inset-0 bg-black" id="modal-new-reservation-bg"></div>
<div style="z-index:910" class="hidden overflow-x-hidden overflow-y-auto fixed inset-0 outline-none focus:outline-none justify-center" id="modal-new-reservation">
  <div id="new_reservation_modal_setup__2" class="border-2 border-gray-500 rounded-lg shadow-lg relative flex flex-col p-10 w-5/6 dark:text-gray-200 bg-white dark:bg-black  outline-none focus:outline-none">
    <div class="flex flex-col">
      <h2 class="flex mb-5">Neue Tischreservierung <%= @location.name %></h2>
      <div class="flex justify-around w-full text-2vw">
        <%= form_with(model: @location, method: :post, url: { action: "create_event" }) do |form| %>
          <%= hidden_field_tag :location_id, @location.id %>
          <%= render "error_messages", resource: form.object %>
          <div class="form-group flex">
            <%= form.text_field :summary, autocomplete: "off", class: "form-control text-2vw", style: "width: 400px", placeholder: "Event Titel, z.B. \"T4 Peter+Mike\"" %>
          </div>
          <div class="form-group flex items-center">
            <input type="date" name="location[date]" id="location_date">
            &nbsp;&nbsp;&nbsp;&nbsp;
            <input type="time" name="location[start_time]" id="location-start-time" class="bg-gray-50 border leading-none border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block ml-10 p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500" min="00:00" value="19:00" required/>
            &nbsp;-&nbsp;
            <input type="time" name="location[end_time]" id="location-end-time" class="bg-gray-50 border leading-none border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500" min="00:00" value="23:00" required/>
          </div>
          <div class="form-group">
            <%= custom_link_to t('back'), "javascript:set_new_reservation_modal()", data: { turbolinks: false }, class: "dark:text-white focus:outline-none focus:ring-8 focus:ring-green-500 focus:ring-opacity-90 border-0 btn btn-primary text-2vw", id: "cancel", tabindex: "1" %>

            <%= form.submit t('save'), class: "btn btn-primary text-2vw" %>
          </div>
          <p class="text-1-5vw leading-6">
            Die Belegung der Tische, das Turnier, die Teilnehmer,
            sowie eine Angabe zur automatischen Heizungssteuerung,
            wird durch eine Namenskonvention im Titel festgelegt.
          </p>
          <p class="text-1-5vw leading-6">
            Der Titel setzt sich zusammen aus einer mit Kommas getrennten
            Liste von Tischbereichen (z.B. T5 oder T6-T8), gefolgt von einem
            Lehrzeichen und dem Eventtitel oder den Spielernamen, Also z.B.
            "Clubabend" oder "NDM Cadre 35/2" oder "Lothar + Gernot".
            Am Ende kann ein Ausrufungszeichen (!) gesetzt werden um zu
            verhindern, dass Heizungen bei Nichtbenutzung während der
            Reservierung abgeschaltet werden.
            Termineinträge, die sich nicht an diese Namenskonvention
            halten und auch nicht mit einem Label wie "info:" oder "BGH:" beginnen,
            werden automatisch gelöscht.
          </p>
        <% end %>
      </div>
    </div>
  </div>
</div>
<div class="w-1/12 grid grid-cols-2 gap-4 mr-4 fixed text-gray-300 hover:text-black text-2vw font-bold" style="right: 10px; top: -10px;">
  <%= custom_link_to scoreboard_location_path(@location.md5, sb_state: "table_scores", :"data-turbo" => false) do %>
    <%= render_svg "icons/information-outline", styles: "responsive-svg fill-current icon-lg m-4 text-white inline-block", title: "home" %>
  <% end %>
  <%= custom_link_to scoreboard_location_path(@location.md5, sb_state: "welcome", :"data-turbo" => false) do %>
    <%= render_svg "icons/home", styles: "responsive-svg fill-current icon-lg m-4 text-white inline-block", title: "home" %>
  <% end %>
</div>
<div class="p-7 lg:p-14 text-gray-200 w-full m-auto flex items-center flex-col bg-cover h-screen bg-center bg-no-repeat" style="background-image: url('/bg_pool2-.jpg')">
  <h1 style="text-shadow: 2px 2px #000000" class="flex text-gray-200 text-3vw"><%= t('home.index.reservation') %>
    - <%= @location.name %></h1>
  <%- if @location.present? %>
    <%- table_status = JSON.parse(File.read(File.join(Rails.root, 'log', 'events'))) rescue [] %>
    <div class="w-3/5 h-2/5 overflow-y-auto mt-5">
      <pre><%= table_status.join("\n") %></pre>
    </div>
    <p>
      <%= custom_link_to "Neue Reservierung", "javascript:new_reservation_mode()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-green-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-primary text-2vw", id: "cancel", tabindex: "1" %>
    </p>
    <p>
      <%= custom_link_to "Exit Kiosk Mode", "javascript:open_kiosk_keyboard()", data: { turbolinks: false }, class: "dark:text-white flex w-full h-full border-4 focus:outline-none focus:ring-8 focus:ring-red-500 focus:ring-opacity-90 border-0 rounded-lg btn btn-danger text-2vw", id: "exit_kiosk", tabindex: "1" %>
    </p>
    <p class="w-3/4 mt-5">
      Reservierungen können direkt hier oder im Google Kalender "BC Wedel" gemacht werden.
      Für den Zugang zum Google Kalender bitte email an gernot.ullrich@gmail.com oder wcauel@gmail.com.
      Es ist dafür eine @gmail.com eMail notwendig. Korrekturen sind derzeit nur im Google Kalender möglich.<br/>
      Die Heizungen werden entsprechend dieser Reservierungen geschaltet (zwei bzw. drei (gr. Tische) Stunden vor Terminbeginn).
    </p>
  <%- end %>
</div>
