<!-----
---
title: Datenbank-Partitionierung und Synchronisierung
summary: 'Das System implementiert eine regionsbasierte Datenbank-Partitionierungsstrategie
  zur Optimierung der Datensynchronisierung zwischen lokalen Servern und dem zentralen
  API-Server. Dieser Ansatz stellt sicher, dass jeder lokale Server nur die für seine
  Region relevanten Daten verwaltet und gleichzeitig Zugriff auf notwendige globale
  Ereignisse hat. Zusätzlich werden regionsunabhängige Daten an alle lokalen Server
  synchronisiert.

  '
version:
published_at: !ruby/object:ActiveSupport::TimeWithZone
  utc: 2025-04-29 21:19:03.426133000 Z
  zone: !ruby/object:ActiveSupport::TimeZone
    name: Europe/Berlin
  time: 2025-04-29 23:19:03.426133000 Z
tags: []
metadata: {}
position: 0
id: 10
---

-->
<div class="container mx-auto my-8 px-4">
  <div class="mx-auto">
    <h2>Datenbank-Partitionierung und Synchronisierung</h2>
    <ul class="@apply list-none">

      <li><h3>Übersicht</h3>
        <p>Das System implementiert eine regionsbasierte Datenbank-Partitionierungsstrategie zur Optimierung der Datensynchronisierung zwischen lokalen Servern und dem zentralen API-Server. Dieser Ansatz stellt sicher, dass jeder lokale Server nur die für seine Region relevanten Daten verwaltet und gleichzeitig Zugriff auf notwendige globale Ereignisse hat. Zusätzlich werden regionsunabhängige Daten an alle lokalen Server synchronisiert.</p>
      </li>

      <li><h3>Hauptkomponenten</h3>
        <h4>1. Regions-Tagging (RegionTaggable)</h4>
        <ul>
          <li>Datensätze werden mit einem <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">region_id</code> markiert, um ihre regionale Zuordnung zu verfolgen</li>
          <li>Ein <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">global_context</code> Boolean-Flag kennzeichnet Datensätze, die an globalen Ereignissen teilnehmen</li>
          <li>Datensätze ohne regionale Abhängigkeiten (region_id ist NULL) werden an alle Server synchronisiert</li>
          <li>Implementiert als Concern in <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">app/models/concerns/region_taggable.rb</code></li>
        </ul>

        <h4>2. Versionsverwaltung</h4>
        <ul>
          <li>Nutzt PaperTrail für die Versionsverfolgung</li>
          <li>Versionen werden mit <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">region_id</code> markiert, um die regionale Relevanz zu verfolgen</li>
          <li>Versionen mit NULL region_id werden als global betrachtet und an alle Server gesendet</li>
        </ul>

        <h4>3. Synchronisierungslogik</h4>
        <ul>
          <li>Lokale Server erhalten nur Daten mit <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">region_id</code> ihrer Region oder <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">global_context = true</code></li>
          <li>Globale Ereignisse (DBU-Turniere, etc.) werden an alle Server synchronisiert</li>
          <li>Regionsunabhängige Daten (Konfigurationen, etc.) werden an alle Server gesendet</li>
        </ul>
      </li>

      <li><h3>Implementierung</h3>
        <h4>RegionTaggable Concern</h4>
        <pre><code class="language-ruby">module RegionTaggable
  extend ActiveSupport::Concern

  included do
    after_save :update_region_tagging
    after_destroy :update_region_tagging
  end

  def find_associated_region_id
    # Berechnet die region_id basierend auf dem Modelltyp
  end

  def global_context?
    # Bestimmt, ob der Datensatz globalen Kontext hat
  end
end</code></pre>

        <h4>Versions-Scope</h4>
        <pre><code class="language-ruby">scope :for_region, ->(region_id) {
  where("region_id IS NULL OR region_id = ?", region_id)
}</code></pre>
      </li>

      <li><h3>Verwendung</h3>
        <h4>Rake Tasks</h4>
        <pre><code class="language-bash"># Region-IDs für alle Modelle aktualisieren
rails region_taggings:update_all_region_ids

# Region-Tagging für alle Modelle aktualisieren
rails region_taggings:update_all

# Global Context für Datensätze setzen
rails region_taggings:set_global_context

# Region-Tagging verifizieren
rails region_taggings:verify</code></pre>

        <h4>Modelle mit RegionTaggable</h4>
        <ul>
          <li>Region, Club, Tournament, League, Party</li>
          <li>Location, LeagueTeam, Game, PartyGame, GameParticipation</li>
          <li>Player, SeasonParticipation, Seeding</li>
        </ul>
      </li>

      <li><h3>Migration von altem System</h3>
        <p>Das System wurde von einem komplexen polymorphic <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">region_taggings</code> System zu einem einfachen <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">region_id</code> + <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">global_context</code> System migriert:</p>
        
        <ol>
          <li><strong>Altes System</strong>: <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">region_ids</code> Array mit polymorphic <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">region_taggings</code> Tabelle</li>
          <li><strong>Neues System</strong>: Einzelne <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">region_id</code> mit <code class="bg-gray-100 dark:bg-gray-800 px-1 py-0.5 rounded">global_context</code> Boolean</li>
        </ol>

        <h4>Vorteile des neuen Systems</h4>
        <ul>
          <li>Einfacher zu verstehen und zu warten</li>
          <li>Bessere Performance durch direkte Indizes</li>
          <li>Klarere Trennung zwischen regionalen und globalen Daten</li>
          <li>Weniger Komplexität in der Synchronisierungslogik</li>
        </ul>
      </li>
    </ul>
  </div>
</div>
