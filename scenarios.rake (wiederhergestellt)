
# frozen_string_literal: true

require 'yaml'
require 'erb'
require 'fileutils'

namespace :scenario do
  desc "List all available scenarios"
  task :list do
    puts "Available scenarios:"
    list_scenarios.each do |scenario|
      environments = list_environments(scenario)
      puts "  #{scenario}: #{environments.join(', ')}"
    end
  end

  desc "Create database dump for scenario"
  task :create_dump, [:scenario_name, :environment] => :environment do |task, args|
    scenario_name = args[:scenario_name]
    environment = args[:environment] || 'development'
    
    if scenario_name.nil?
      puts "Usage: rake scenario:create_dump[scenario_name,environment]"
      puts "Example: rake scenario:create_dump[carambus_api,development]"
      exit 1
    end
    
    create_database_dump(scenario_name, environment)
  end

  desc "Restore database dump for scenario"
  task :restore_dump, [:scenario_name, :environment] => :environment do |task, args|
    scenario_name = args[:scenario_name]
    environment = args[:environment] || 'development'
    
    if scenario_name.nil?
      puts "Usage: rake scenario:restore_dump[scenario_name,environment]"
      puts "Example: rake scenario:restore_dump[carambus_api,development]"
      exit 1
    end
    
    restore_database_dump(scenario_name, environment)
  end

  desc "Generate configuration files from carambus_data/scenarios/"
  task :generate_configs, [:scenario_name, :environment] => :environment do |task, args|
    scenario_name = args[:scenario_name]
    environment = args[:environment] || 'development'
    
    if scenario_name.nil?
      puts "Usage: rake scenario:generate_configs[scenario_name,environment]"
      puts "Example: rake scenario:generate_configs[carambus_location_2459,development]"
      exit 1
    end
    
    generate_configuration_files(scenario_name, environment)
  end

  private

  def carambus_data_path
    @carambus_data_path ||= File.expand_path('../carambus_data', Rails.root)
  end

  def scenarios_path
    @scenarios_path ||= File.join(carambus_data_path, 'scenarios')
  end

  def templates_path
    @templates_path ||= File.join(carambus_data_path, 'templates')
  end

  def list_scenarios
    scenarios = Dir.glob(File.join(scenarios_path, '*')).select { |f| File.directory?(f) }
    scenarios.map { |s| File.basename(s) }
  end

  def list_environments(scenario_name)
    config_file = File.join(scenarios_path, scenario_name, 'config.yml')
    return [] unless File.exist?(config_file)
    
    scenario_config = YAML.load_file(config_file)
    scenario_config['environments'].keys
  end

  def generate_configuration_files(scenario_name, environment)
    puts "Generating configuration files for #{scenario_name} (#{environment})..."
    
    # Load scenario configuration
    config_file = File.join(scenarios_path, scenario_name, 'config.yml')
    unless File.exist?(config_file)
      puts "Error: Scenario configuration not found: #{config_file}"
      return false
    end
    
    scenario_config = YAML.load_file(config_file)
    env_config = scenario_config['environments'][environment]
    
    if env_config.nil?
      puts "Error: Environment '#{environment}' not found in scenario configuration"
      return false
    end
    
    # Create environment directory
    env_dir = File.join(scenarios_path, scenario_name, environment)
    FileUtils.mkdir_p(env_dir)
    
    # Generate carambus.yml in environment directory
    generate_carambus_yml(scenario_config, env_config, env_dir)
    
    # Generate database.yml in environment directory
    generate_database_yml(scenario_config, env_config, env_dir)
    
    # Generate deploy files in environment directory (only for development)
    generate_deploy_files(scenario_config, env_config, env_dir)
    
    puts "✅ Configuration files generated for #{scenario_name} (#{environment})"
    puts "   Location: #{env_dir}"
    true
  end

  def generate_carambus_yml(scenario_config, env_config, env_dir)
    template_file = File.join(templates_path, 'carambus', 'carambus.yml.erb')
    unless File.exist?(template_file)
      puts "Error: Carambus template not found: #{template_file}"
      return false
    end

    template = ERB.new(File.read(template_file))
    @scenario = scenario_config['scenario']
    @config = env_config
    @environment = File.basename(env_dir)  # 'development' oder 'production'
    
    content = template.result(binding)
    File.write(File.join(env_dir, 'carambus.yml'), content)
    puts "   Generated: #{File.join(env_dir, 'carambus.yml')}"
    true
  end

  def generate_database_yml(scenario_config, env_config, env_dir)
    template_file = File.join(templates_path, 'database', 'database.yml.erb')
    unless File.exist?(template_file)
      puts "Error: Database template not found: #{template_file}"
      return false
    end

    template = ERB.new(File.read(template_file))
    @config = env_config
    @environment = File.basename(env_dir)  # 'development' oder 'production'
    
    content = template.result(binding)
    File.write(File.join(env_dir, 'database.yml'), content)
    puts "   Generated: #{File.join(env_dir, 'database.yml')}"
    true
  end

  def generate_deploy_files(scenario_config, env_config, env_dir)
    # Only generate deploy files for development environment
    return unless File.basename(env_dir) == 'development'
    
    scenario = scenario_config['scenario']
    
    # Get production environment config for deploy/production.rb
    production_config = scenario_config['environments']['production']
    
    # Generate deploy.rb (main deploy configuration)
    deploy_rb_content = <<~RUBY
      # frozen_string_literal: true
      
      # config valid for current version and patch releases of Capistrano
      lock "~> 3.17.0"
      
      set :application, "#{scenario['application_name']}"
      set :repo_url, "git@github.com:gullrich/#{scenario['application_name']}.git"
      set :basename, "#{scenario['basename']}"
      
      # Default branch is :master
      ask :branch, `git rev-parse --abbrev-ref HEAD`.chomp
      
      # Default deploy_to directory is /var/www/my_app_name
      set :deploy_to, "/var/www/#{scenario['basename']}"
      
      # Default value for :format is :airbrussh.
      set :format, :airbrussh
      
      # You can configure the Airbrussh format using :format_options.
      # These are the defaults.
      set :format_options, command_output: true, log_file: "log/capistrano.log", color: :auto, truncate: :auto
      
      # Default value for :pty is false
      set :pty, true
      
      # Default value for :linked_files is []
      append :linked_files, "config/database.yml", "config/carambus.yml"
      
      # Default value for linked_dirs is []
      append :linked_dirs, "log", "tmp/pids", "tmp/cache", "tmp/sockets", "public/system"
      
      # Default value for default_env is {}
      set :default_env, { path: "/opt/ruby/bin:$PATH" }
      
      # Default value for local_user is ENV['USER']
      # ask :local_user, -> { `git config user.name`.chomp }
      
      # Default value for keep_releases is 5
      set :keep_releases, 5
      
      # Uncomment the following to require manually verifying the host key before first deploy.
      # set :ssh_options, verify_host_key: :secure
      
      namespace :deploy do
        desc "Restart application"
        task :restart do
          on roles(:app), in: :sequence, wait: 10 do
            execute "./bin/#{env_config['puma_script'] || 'manage-puma.sh'}"
          end
        end
      end
      
      after "deploy:publishing", "deploy:restart"
    RUBY
    
    File.write(File.join(env_dir, 'deploy.rb'), deploy_rb_content)
    puts "   Generated: #{File.join(env_dir, 'deploy.rb')}"
    
    # Generate deploy/production.rb
    production_rb_content = <<~RUBY
      # server-based syntax
      # ======================
      # Defines a single server with a list of roles and multiple properties.
      # You can define all roles on a single server, or split them:

      server '#{production_config['ssh_host']}', user: 'www-data', roles: %w{app db web}, ssh_options: {port: "#{production_config['ssh_port']}"} # #{scenario['name']}

      # Puma auf Port ...
      set :puma_port, "#{production_config['webserver_port']}"
      set :rails_env, 'production'
      set :branch, '#{scenario['branch']}'

      # Configuration
      # =============
      # You can set any configuration variable like in config/deploy.rb
      # These variables are then only loaded and set in this stage.
      # For available Capistrano configuration variables see the documentation page.
      # http://capistranorb.com/documentation/getting-started/configuration/
      # Feel free to add new variables to customise your setup.

      # Custom SSH Options
      # ==================
      # You may pass any option but keep in mind that net/ssh understands a
      # limited set of options, consult the Net::SSH documentation.
      # http://net-ssh.github.io/net-ssh/classes/Net/SSH.html#method-c-start
      #
      # Global options
      # --------------
      #  set :ssh_options, {
      #    keys: %w(/home/rlisowski/.ssh/id_rsa),
      #    forward_agent: false,
      #    auth_methods: %w(password)
      #  }
      #
      # The server-based syntax can be used to override options:
      # ------------------------------------
      # server 'carambus.de',
      #   user: 'user_name',
      #   roles: %w{web app},
      #   ssh_options: {
      #         user: 'user_name', # overrides user setting above
      #         keys: %w(/user_name/.ssh/id_rsa),
      #         forward_agent: false,
      #         auth_methods: %w(publickey password)
      #         # password: 'please use keys'
      #       }
    RUBY
    
    # Create deploy directory
    deploy_dir = File.join(env_dir, 'deploy')
    FileUtils.mkdir_p(deploy_dir)
    
    File.write(File.join(deploy_dir, 'production.rb'), production_rb_content)
    puts "   Generated: #{File.join(deploy_dir, 'production.rb')}"
  end

  def restore_database_dump(scenario_name, environment)
    puts "Restoring database dump for #{scenario_name} (#{environment})..."
    
    # Load scenario configuration
    config_file = File.join(scenarios_path, scenario_name, 'config.yml')
    unless File.exist?(config_file)
      puts "Error: Scenario configuration not found: #{config_file}"
      return false
    end
    
    scenario_config = YAML.load_file(config_file)
    env_config = scenario_config['environments'][environment]
    
    if env_config.nil?
      puts "Error: Environment '#{environment}' not found in scenario configuration"
      return false
    end
    
    database_name = env_config['database_name']
    dump_dir = File.join(scenarios_path, scenario_name, 'database_dumps')
    
    # Find latest dump file
    dump_files = Dir.glob(File.join(dump_dir, "#{scenario_name}_#{environment}_*.sql.gz"))
    if dump_files.empty?
      puts "Error: No dump files found in #{dump_dir}"
      return false
    end
    
    latest_dump = dump_files.sort.last
    puts "Using dump: #{File.basename(latest_dump)}"
    
    # Drop and recreate database
    puts "Dropping database #{database_name}..."
    system("dropdb #{database_name}") if system("psql -lqt | cut -d \| -f 1 | grep -qw #{database_name}")
    
    puts "Creating database #{database_name}..."
    system("createdb #{database_name}")
    
    # Restore dump
    puts "Restoring from #{latest_dump}..."
    if system("gunzip -c #{latest_dump} | psql #{database_name}")
      puts "✅ Database restored successfully"
      true
    else
      puts "❌ Database restore failed"
      false
    end
  end

  def create_database_dump(scenario_name, environment)
    puts "Creating database dump for #{scenario_name} (#{environment})..."
    
    # Load scenario configuration
    config_file = File.join(scenarios_path, scenario_name, 'config.yml')
    unless File.exist?(config_file)
      puts "Error: Scenario configuration not found: #{config_file}"
      return false
    end
    
    scenario_config = YAML.load_file(config_file)
    env_config = scenario_config['environments'][environment]
    
    if env_config.nil?
      puts "Error: Environment '#{environment}' not found in scenario configuration"
      return false
    end
    
    database_name = env_config['database_name']
    dump_dir = File.join(scenarios_path, scenario_name, 'database_dumps')
    FileUtils.mkdir_p(dump_dir)
    
    # Create dump filename with timestamp
    timestamp = Time.now.strftime('%Y%m%d_%H%M%S')
    dump_file = File.join(dump_dir, "#{scenario_name}_#{environment}_#{timestamp}.sql.gz")
    
    # Create dump
    puts "Creating dump of #{database_name}..."
    if system("pg_dump #{database_name} | gzip > #{dump_file}")
      puts "✅ Database dump created: #{File.basename(dump_file)}"
      puts "   Size: #{File.size(dump_file) / 1024 / 1024} MB"
      true
    else
      puts "❌ Database dump failed"
      false
    end
  end
end
